#include <stdbool.h>
#include <stdint.h>

#define UNSET_U8 0xCA
#define UNSET_U32 0xCACACACA

typedef struct {

  /**
   * Set what pins to select when doing configuration. Each option will have
   * its value based on the pin_mask
   */
  uint8_t pin_mask;

  /**
   * The GPIODIRregister is the data direction register. Setting a bit in
   * theGPIODIRregister configures the corresponding pin to be an output,
   * while clearing a bit configures the corresponding pin to be an input. All
   * bits are cleared by a reset, meaning all GPIO pins are inputs by default.
   */
  bool output;

  /**
   * The GPIOISregister is the interrupt sense register. Setting a bit in
   * theGPIOISregister configures the corresponding pin to detect levels,
   * while clearing a bit configures the corresponding pin to detect edges.
   * All bits are cleared by a reset. Note: To prevent false interrupts, the
   * following steps should be taken when re-configuring GPIO edge and
   * interrupt sense registers:
   * 1. Mask the corresponding port by clearing theIMEfield in
   * theGPIOIMregister.
   * 2. Configure theISfield in theGPIOISregister and theIBEfield in
   * theGPIOIBEregister.
   * 3. Clear theGPIORISregister.
   * 4. Unmask the port by setting theIMEfield in theGPIOIMregister.
   */
  bool interrupt_sense;

  /**
   * The GPIOIBEregister allows both edges to cause interrupts. When the
   * corresponding bit in the GPIOInterruptSense(GPIOIS) register (see page
   * 664) is set to detect edges, setting a bit in the GPIOIBEregister
   * configures the corresponding pin to detect both rising and falling edges,
   * regardless of the corresponding bit in theGPIOInterruptEvent(GPIOIEV)
   * register (see page 666). Clearing a bit configures the pin to be
   * controlled by theGPIOIEVregister. All bits are cleared by a reset. Note:
   * To prevent false interrupts, the following steps should be taken when
   * re-configuring GPIO edge and interrupt sense registers:
   * 1. Mask the corresponding port by clearing theIMEfield in
   * theGPIOIMregister.
   * 2. Configure theISfield in theGPIOISregister and theIBEfield in
   * theGPIOIBEregister.
   * 3. Clear theGPIORISregister.
   * 4. Unmask the port by setting theIMEfield in theGPIOIMregister.
   */
  bool interrupt_both_edges;

  /**
   * The GPIOIEVregister is the interrupt event register. Setting a bit in
   * theGPIOIEVregister configures the corresponding pin to detect rising
   * edges or high levels, depending on the corresponding bit value in
   * theGPIOInterruptSense(GPIOIS) register (see page 664). Clearing a bit
   * configures the pin to detect falling edges or low levels, depending on
   * the corresponding bit value in theGPIOIS register. All bits are cleared
   * by a reset.
   */
  bool interrupt_event;

  /**
   * The GPIOIMregister is the interrupt mask register. Setting a bit in
   * theGPIOIMregister allows interrupts that are generated by the
   * corresponding pin to be sent to the interrupt controller on the combined
   * interrupt signal. Clearing a bit prevents an interrupt on the
   * corresponding pin from being sent to the interrupt controller. All bits
   * are cleared by a reset.
   */
  bool interrupt_mask;

  /**
   * The GPIOAFSELregister is the mode control select register. If a bit is
   * clear, the pin is used as a GPIO and is controlled by the GPIO registers.
   * Setting a bit in this register configures the corresponding GPIO line to
   * be controlled by an associated peripheral. Several possible peripheral
   * functions are multiplexed on each GPIO. TheGPIOPortControl(GPIOPCTL)
   * register is used to select one of the possible functions. Table 23-5 on
   * page 1351 details which functions are muxed on each GPIO pin. The reset
   * value for this register is 0x0000.0000 for GPIO ports that are not listed
   * in the table below.
   */
  bool alternate_function_select;

  /**
   * The GPIODR2Rregister is the 2-mA drive control register. Each GPIO signal
   * in the port can be individually configured without affecting the other
   * pads. When setting theDRV2bit for a GPIO signal, the correspondingDRV4bit
   * in theGPIODR4Rregister andDRV8bit in theGPIODR8Rregister are
   * automatically cleared by hardware. By default, all GPIO pins have 2-mA
   * drive.
   */
  bool drive_select_2mA;

  /**
   * The GPIODR4Rregister is the 4-mA drive control register. Each GPIO signal
   * in the port can be individually configured without affecting the other
   * pads. When setting theDRV4bit for a GPIO signal, the correspondingDRV2bit
   * in theGPIODR2Rregister andDRV8bit in theGPIODR8Rregister are
   * automatically cleared by hardware.
   */
  bool drive_select_4mA;

  /**
   * The GPIODR8Rregister is the 8-mA drive control register. Each GPIO signal
   * in the port can be individually configured without affecting the other
   * pads. When setting theDRV8bit for a GPIO signal, the correspondingDRV2bit
   * in theGPIODR2Rregister andDRV4bit in theGPIODR4Rregister are
   * automatically cleared by hardware. The 8-mA setting is also used for
   * high-current operation. Note: There is no configuration difference
   * between 8-mA and high-current operation. The additional current capacity
   * results from a shift in the VOH/VOL levels. See “Recommended Operating
   * Conditions” on page 1360 for further information.
   */
  bool drive_select_8mA;

  /**
   * The GPIOODRregister is the open drain control register. Setting a bit in
   * this register enables the open-drain configuration of the corresponding
   * GPIO pad. When open-drain mode is enabled, the corresponding bit should
   * also be set in theGPIODigitalEnable(GPIODEN) register (see page 682).
   * Corresponding bits in the drive strength and slew rate control registers
   * (GPIODR2R, GPIODR4R, GPIODR8R, andGPIOSLR) can be set to achieve the
   * desired fall times. The GPIO acts as an input if the corresponding bit in
   * theGPIODIRregister is cleared. If open drain is selected while the GPIO
   * is configured as an input, the GPIO will remain an input and the
   * open-drain selection has no effect until the GPIO is changed to an
   * output. When using the I2C module, in addition to configuring the data
   * pin to open drain, theGPIOAlternate FunctionSelect(GPIOAFSEL) register
   * bits for the I2C clock and data pins should be set (see examples in
   * “Initialization and Configuration” on page 656).
   */
  bool open_drain_select;

  /**
   * The GPIOPURregister is the pull-up control register. When a bit is set, a
   * weak pull-up resistor on the corresponding GPIO signal is enabled.
   * Setting a bit inGPIOPURautomatically clears the corresponding bit in
   * theGPIOPull-DownSelect(GPIOPDR) register (see page 679). Write access to
   * this register is protected with theGPIOCRregister. Bits inGPIOCRthat are
   * cleared prevent writes to the equivalent bit in this register.
   */
  bool pull_up_select;

  /**
   * The GPIOPDRregister is the pull-down control register. When a bit is set,
   * a weak pull-down resistor on the corresponding GPIO signal is enabled.
   * Setting a bit inGPIOPDRautomatically clears the corresponding bit in
   * theGPIOPull-UpSelect(GPIOPUR) register (see page 677).
   */
  bool pull_down_select;

  /**
   * The GPIOSLRregister is the slew rate control register. Slew rate control
   * is only available when using the 8-mA drive strength option. The
   * selection of drive strength is done through theGPIO8-mA
   * DriveSelect(GPIODR8R) register.
   */
  bool slew_rate_control_select;

  /**
   * Note: Pins configured as digital inputs are Schmitt-triggered.
   * The GPIODENregister is the digital enable register. By default, all GPIO
   * signals except those listed below are configured out of reset to be
   * undriven (tristate). Their digital function is disabled; they do not
   * drive a logic value on the pin and they do not allow the pin voltage into
   * the GPIO receiver. To use the pin as a digital input or output (either
   * GPIO or alternate function), the correspondingGPIODEN bit must be set.
   */
  bool digital_enable;

  /**
   * The GPIOLOCKregister enables write access to theGPIOCRregister (see page
   * 685). Writing 0x4C4F.434B to theGPIOLOCKregister unlocks
   * theGPIOCRregister. Writing any other value to the GPIOLOCKregister
   * re-enables the locked state. Reading theGPIOLOCKregister returns the lock
   * status rather than the 32-bit value that was previously written.
   * Therefore, when write accesses are disabled, or locked, reading
   * theGPIOLOCKregister returns 0x0000.0001. When write accesses are enabled,
   * or unlocked, reading theGPIOLOCKregister returns 0x0000.0000.
   */
  uint32_t lock;

  /**
   * Important: This register is only valid for ports and pins that can be
   * used as ADC AINx inputs. If any pin is to be used as an ADC input, the
   * appropriate bit inGPIOAMSELmust be set to disable the analog isolation
   * circuit. The GPIOAMSELregister controls isolation circuits to the analog
   * side of a unified I/O pad. Because the GPIOs may be driven by a 5-V
   * source and affect analog operation, analog circuitry requires isolation
   * from the pins when they are not used in their analog function. Each bit
   * of this register controls the isolation circuitry for the corresponding
   * GPIO signal. For information on which GPIO pins can be used for ADC
   * functions, refer to Table 23-5 on page 1351.
   */
  bool analog_mode_select;

  /**
   * The GPIOPCTLregister is used in conjunction with theGPIOAFSELregister and
   * selects the specific peripheral signal for each GPIO pin when using the
   * alternate function mode. Most bits in the GPIOAFSELregister are cleared
   * on reset, therefore most GPIO pins are configured as GPIOs by default.
   * When a bit is set in theGPIOAFSELregister, the corresponding GPIO signal
   * is controlled by an associated peripheral. TheGPIOPCTLregister selects
   * one out of a set of peripheral functions for each GPIO, providing
   * additional flexibility in signal definition. For information on the
   * defined encodings for the bit fields in this register, refer to Table
   * 23-5 on page 1351. The reset value for this register is 0x0000.0000 for
   * GPIO ports that are not listed in the table below. Note: If a particular
   * input signal to a peripheral is assigned to two different GPIO port pins,
   * the signal is assigned to the port with the lowest letter and the
   * assignment to the higher letter port is ignored. If a particular output
   * signal from a peripheral is assigned to two different GPIO port pins, the
   * signal will output to both pins. Assigning an output signal from a
   * peripheral to two different GPIO pins is not recommended.
   */
  uint8_t port_control;

  /**
   * This register is used to configure a GPIO pin as a source for the ADC
   * trigger. Note that if the Port BGPIOADCCTLregister is cleared, PB4 can
   * still be used as an external trigger for the ADC. This is a legacy mode
   * which allows code written for previous devices to operate on this
   * microcontroller.
   */
  bool adc_control;

  /**
   * This register is used to configure a GPIO pin as a source for the μDMA
   * trigger.
   */
  bool dma_control;

} GpioInitOpts;
#define gpio_init(port, ...)                                                   \
   IGNORE_INITIALIZER_WARNING(                                                  \
      gpio_init_(port, (GpioInitOpts){                                         \
                           .pin_mask = UNSET_U8,                               \
                           .output = UNSET_U8,                                 \
                           .interrupt_sense = UNSET_U8,                        \
                           .interrupt_both_edges = UNSET_U8,                   \
                           .interrupt_event = UNSET_U8,                        \
                           .interrupt_mask = UNSET_U8,                         \
                           .alternate_function_select = UNSET_U8,              \
                           .drive_select_2mA = UNSET_U8,                       \
                           .drive_select_4mA = UNSET_U8,                       \
                           .drive_select_8mA = UNSET_U8,                       \
                           .open_drain_select = UNSET_U8,                      \
                           .pull_up_select = UNSET_U8,                         \
                           .pull_down_select = UNSET_U8,                       \
                           .slew_rate_control_select = UNSET_U8,               \
                           .digital_enable = UNSET_U8,                         \
                           .analog_mode_select = UNSET_U8,                     \
                           .port_control = UNSET_U8,                           \
                           .adc_control = UNSET_U8,                            \
                           .dma_control = UNSET_U8,                            \
                           .lock = UNSET_U32,                                  \
                           __VA_ARGS__ /* comment to appease clang-format */   \
                       }))
uint32_t *gpio_init_(const int port, const GpioInitOpts opts) {

  // clang-format off
    if (opts.output == true) *GPIO_DIR(port) |= opts.pin_mask;
    if (opts.interrupt_mask == true) *GPIO_IM(port) |= opts.pin_mask;
    if (opts.digital_enable == true) *GPIO_DEN(port) |= opts.pin_mask;
    if (opts.pull_up_select == true) *GPIO_PUR(port) |= opts.pin_mask;
    if (opts.adc_control == true) *GPIO_ADCCTL(port) |= opts.pin_mask;
    if (opts.dma_control == true) *GPIO_DMACTL(port) |= opts.pin_mask;
    if (opts.interrupt_sense == true) *GPIO_IS(port) |= opts.pin_mask;
    if (opts.interrupt_event == true) *GPIO_IEV(port) |= opts.pin_mask;
    if (opts.pull_down_select == true) *GPIO_PDR(port) |= opts.pin_mask;
    if (opts.drive_select_2mA == true) *GPIO_DR2R(port) |= opts.pin_mask;
    if (opts.drive_select_4mA == true) *GPIO_DR4R(port) |= opts.pin_mask;
    if (opts.drive_select_8mA == true) *GPIO_DR8R(port) |= opts.pin_mask;
    if (opts.open_drain_select == true) *GPIO_ODR(port) |= opts.pin_mask;
    if (opts.analog_mode_select == true) *GPIO_AMSEL(port) |= opts.pin_mask;
    if (opts.interrupt_both_edges == true) *GPIO_IBE(port) |= opts.pin_mask;
    if (opts.slew_rate_control_select == true) *GPIO_SLR(port) |= opts.pin_mask;
    if (opts.alternate_function_select == true) *GPIO_AFSEL(port) |= opts.pin_mask;

    if (opts.output == false) *GPIO_DIR(port) &= ~opts.pin_mask;
    if (opts.interrupt_mask == false) *GPIO_IM(port) &= ~opts.pin_mask;
    if (opts.digital_enable == false) *GPIO_DEN(port) &= ~opts.pin_mask;
    if (opts.pull_up_select == false) *GPIO_PUR(port) &= ~opts.pin_mask;
    if (opts.adc_control == false) *GPIO_ADCCTL(port) &= ~opts.pin_mask;
    if (opts.dma_control == false) *GPIO_DMACTL(port) &= ~opts.pin_mask;
    if (opts.interrupt_sense == false) *GPIO_IS(port) &= ~opts.pin_mask;
    if (opts.interrupt_event == false) *GPIO_IEV(port) &= ~opts.pin_mask;
    if (opts.pull_down_select == false) *GPIO_PDR(port) &= ~opts.pin_mask;
    if (opts.drive_select_2mA == false) *GPIO_DR2R(port) &= ~opts.pin_mask;
    if (opts.drive_select_4mA == false) *GPIO_DR4R(port) &= ~opts.pin_mask;
    if (opts.drive_select_8mA == false) *GPIO_DR8R(port) &= ~opts.pin_mask;
    if (opts.open_drain_select == false) *GPIO_ODR(port) &= ~opts.pin_mask;
    if (opts.analog_mode_select == false) *GPIO_AMSEL(port) &= ~opts.pin_mask;
    if (opts.interrupt_both_edges == false) *GPIO_IBE(port) &= ~opts.pin_mask;
    if (opts.slew_rate_control_select == false) *GPIO_SLR(port) &= ~opts.pin_mask;
    if (opts.alternate_function_select == false) *GPIO_AFSEL(port) &= ~opts.pin_mask;
  // clang-format on

  if (opts.port_control != UNSET_U8) {
    uint8_t mux_val = opts.port_control & 0b1111;

    int i, bit;
    uint32_t port_control_result = 0;
    uint32_t port_control_mask = 0;
    // port_control is set up as eight 4bit values in the 32bit register.
    // For each toggled bit in the pin mask, we can set the 4bit value at
    // the respective gpio pin in the register
    for (i = 0, bit = 1; i < 8; i++, bit <<= 1) {
      if (opts.pin_mask & bit) {
        // Multiply by four because each mux control is 4 bits.
        port_control_result |= ((mux_val) << (i * 4));
        port_control_mask |= (0b1111 << (i * 4));
      }
    }
    uint32_t pctl_reg = *GPIO_PCTL(port);
    // Clear the port controls old values
    pctl_reg &= ~port_control_mask;
    // Update the port control to have the new values
    pctl_reg |= port_control_result;
    *GPIO_PCTL(port) = pctl_reg;
  }

  if (opts.lock != UNSET_U32)
    *GPIO_LOCK(port) = opts.lock;

  // Return the data register with the correct mask
  return ((volatile uint8_t *)(port + (opts.pin_mask << 2)));
}
